Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук

Кафедра «Програмної інженерії»



ЗВІТ
з практичної роботи №2
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення»




Виконав:                                                                                                Перевірив:
ст. гр. ПЗПІ-22-6 ст.                                                                             викладач кафедри ПІ
Гармаєв Михайло                                                                                 Сокорчук І. П.





 
Харків 
2024

2 Методи рефакторингу коду програмного забезпечення
2.1  Мета роботи 
   Навчити студентів основним методам рефакторингу коду на основі реальних прикладів з їхніх власних програмних проєктів. Студенти повинні навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.
2.2  Завдання до виконання
Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code». Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів. Кожен метод рефакторингу повинен супроводжуватись:
* Описом проблеми, яку вирішує даний метод.
* Кодом до і після застосування методу рефакторингу.
* Поясненням переваг використаного методу.

2.3  Хід роботи
Вступ
Рефакторинг — це процес покращення внутрішньої структури програмного коду без зміни його зовнішньої поведінки. Завдяки рефакторингу можна підвищити читабельність, зменшити дублювання коду та спростити подальше супроводження програмного забезпечення. У цій доповіді ми розглянемо три методи рефакторингу, які допомагають покращити якість коду.
Replace Data Value with Object
Існує безліч випадків, коли в коді використовуються примітивні типи даних, такі як рядки або числа, для представлення суттєвих концепцій – наприклад, номера телефону, валютних сум або ідентифікаторів. Метод Replace Data Value with Object полягає в тому, щоб замінити примітивне значення спеціалізованим об’єктом. Це дозволяє не лише зберігати значення, а й інкапсулювати логіку, пов’язану з перевіркою, форматуванням та іншими операціями. Такий підхід зменшує ризик помилок, пов’язаних із некоректними даними, і покращує розширюваність системи.
Приклади коду
До рефакторингу
Уявімо, що в класі Customer зберігається номер телефону як рядок. Використання простого типу даних не дозволяє вбудувати механізм перевірки коректності номеру. Код виглядає наступним чином:

class Customer {
    String phoneNumber;

    Customer(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    void printPhoneNumber() {
        System.out.println("Телефон: " + phoneNumber);
    }
}

У цьому варіанті клас не має механізмів перевірки формату або інших операцій над номером, що може призвести до використання невірних даних у інших частинах програми.
Після рефакторингу
За допомогою методу Replace Data Value with Object ми створюємо окремий клас PhoneNumber, який інкапсулює всі аспекти роботи з номером телефону – перевірку формату, зберігання та можливе форматування. Код після змін:

class PhoneNumber {
    private String number;

    PhoneNumber(String number) {
        if (!isValid(number)) {
            throw new IllegalArgumentException("Невірний формат номера телефону");
        }
        this.number = number;
    }

    private boolean isValid(String number) {
        // Простий приклад валідації: перевірка на довжину та наявність лише цифр
        return number != null && number.matches("\\d{10}");
    }

    @Override
    public String toString() {
        // Можна додати форматування номеру, наприклад, (XXX) XXX-XXXX
        return number;
    }
}

class Customer {
    private PhoneNumber phoneNumber;

    Customer(String phoneNumber) {
        this.phoneNumber = new PhoneNumber(phoneNumber);
    }

    void printPhoneNumber() {
        System.out.println("Телефон: " + phoneNumber);
    }
}
Застосування цього методу дозволяє:
• Інкапсулювати логіку: Всі операції, пов’язані з номером телефону, зосереджені в одному класі.
• Підвищити безпеку: Неможливість створити об’єкт з неправильним номером телефону забезпечує додатковий рівень захисту.
• Покращити підтримку: Якщо з’явиться потреба змінити правила перевірки чи форматування, це можна зробити в одному місці, не торкаючись інших частин коду.
Replace Parameter with Method
При розробці класів часто зустрічається ситуація, коли метод приймає параметр, який насправді завжди може бути отриманий із внутрішнього стану об’єкта або обчислений всередині самого методу. Метод Replace Parameter with Method дозволяє спростити сигнатуру методів, замінюючи параметр виклику на метод, який повертає потрібне значення.
Прикладом може служити клас TaxCalculator, де метод розрахунку податку приймає як дохід, так і ставку податку як параметри. Така схема змушує клієнта методу завжди знати і передавати два значення:
Приклади коду
До рефакторингу
Приклад класу, де метод приймає параметр, який може бути визначений всередині класу:
class TaxCalculator {
    // Метод розрахунку податку приймає ставку податку як параметр
    public double calculateTax(double income, double taxRate) {
        return income * taxRate;
    }
}

class Invoice {
    private double income;

    Invoice(double income) {
        this.income = income;
    }

    double getIncome() {
        return income;
    }
}
Приклад виклику:
Invoice invoice = new Invoice(10000);
TaxCalculator calculator = new TaxCalculator();
double tax = calculator.calculateTax(invoice.getIncome(), 0.15);
System.out.println("Податок: " + tax);
Після рефакторингу
Переходимо до варіанту, де ставка податку є властивістю класу TaxCalculator, тому параметр taxRate більше не потрібен під час виклику методу:
class TaxCalculator {
    private double taxRate;

    TaxCalculator(double taxRate) {
        this.taxRate = taxRate;
    }

    // Тепер метод не приймає ставку податку, а використовує внутрішнє значення
    public double calculateTax(double income) {
        return income * taxRate;
    }
}

class Invoice {
    private double income;

    Invoice(double income) {
        this.income = income;
    }

    double getIncome() {
        return income;
    }
}

// Приклад використання
public class Demo {
    public static void main(String[] args) {
        Invoice invoice = new Invoice(10000);
        TaxCalculator calculator = new TaxCalculator(0.15);
        double tax = calculator.calculateTax(invoice.getIncome());
        System.out.println("Податок: " + tax);
    }
}

Застосування цього методу має наступні переваги:
• Спрощення API: Зменшення кількості параметрів у сигнатурі методу робить його виклик простішим та інтуїтивно зрозумілішим.
• Інкапсуляція даних: Ставка податку тепер є внутрішнім станом об’єкта, що відповідає принципу інкапсуляції.
• Гнучкість налаштувань: При зміні бізнес-логіки достатньо змінити лише властивість класу, не змінюючи всі виклики методу.
Push Down Field
Іноді в ієрархії класів в базовому класі з’являються поля, які використовуються лише в деяких підкласах. Це може призводити до надлишкового ускладнення базового класу, який містить дані, не актуальні для всіх його підтипів. Метод Push Down Field дозволяє перемістити такі поля безпосередньо в ті підкласи, де вони справді потрібні. Це покращує зрозумілість ієрархії та сприяє чіткому розподілу відповідальності.
Приклад коду
До рефакторингу
Приклад ієрархії класів, де поле department знаходиться в базовому класі Employee, хоча воно актуальне лише для певних типів співробітників:
class Employee {
    protected String name;
    // Поле department є спільним для всіх співробітників, хоча використовується не всюди
    protected String department;

    Employee(String name, String department) {
        this.name = name;
        this.department = department;
    }
}

class Manager extends Employee {
    Manager(String name, String department) {
        super(name, department);
    }
    // Менеджер може використовувати додаткові методи, але department може бути зайвим для інших типів
}

class Developer extends Employee {
    Developer(String name, String department) {
        super(name, department);
    }
    // Розробники мають специфічну логіку, де department може відрізнятися або взагалі не використовуватися
}

Така структура створює зайву інформацію для класів, де поле department може бути неактуальним або використовуватися інакше.
Після рефакторингу
Якщо поле department є релевантним лише для менеджерів, його варто перемістити до класу Manager:
class Employee {
    protected String name;

    Employee(String name) {
        this.name = name;
    }
}

class Manager extends Employee {
    private String department;

    Manager(String name, String department) {
        super(name);
        this.department = department;
    }

    String getDepartment() {
        return department;
    }
}

class Developer extends Employee {
    Developer(String name) {
        super(name);
    }
    // Поле department видалено, оскільки воно не використовується в цьому класі
}

// Приклад використання
public class DemoPushDownField {
    public static void main(String[] args) {
        Manager manager = new Manager("Олена", "Продаж");
        System.out.println("Менеджер " + manager.name + " працює в відділі " + manager.getDepartment());

        Developer developer = new Developer("Іван");
        System.out.println("Розробник " + developer.name);
    }
}

Метод Push Down Field дозволяє:
• Зменшити надлишковість: Переміщення непотрібного поля з базового класу до тих підкласів, де воно використовується, зменшує навантаження на базовий клас.
• Покращити організацію коду: Розподіл полів за відповідними класами підвищує логічну структуру та зручність підтримки ієрархії.
• Забезпечити чіткий розподіл відповідальності: Кожен клас містить лише ті дані, які стосуються його специфічних функцій.
2.4  Висновок
У даній доповіді було розглянуто три методи рефакторингу коду:
Replace Data Value with Object – дозволяє інкапсулювати примітивні дані в окремий клас, що сприяє покращенню валідації та розширення функціоналу.
Replace Parameter with Method – спрощує сигнатури методів шляхом заміни параметрів методами, які отримують необхідні дані безпосередньо з внутрішнього стану об’єкта.
Push Down Field – покращує дизайн ієрархії класів шляхом переміщення полів, що використовуються лише в підкласах, із загального базового класу.
Ці методи сприяють зниженню дублювання коду, покращенню його модульності та підтримуваності, що є важливими аспектами у розробці програмного забезпечення.
2.5  Посилання 
Посилання на відеозапис - https://youtu.be/NMCXR8QltTg 
Посилання на GitHub репозиторій - https://github.com/NureHarmaievMykhailo/arkpz-pzpi-22-6-harmaiev-mykhailo/tree/main/Pract2 

